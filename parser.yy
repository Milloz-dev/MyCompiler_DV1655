%{
#include "Node.h"
#include <iostream>
#include <cstdlib>
#include <cstring>
#include "parser.tab.h"

using namespace std;

extern int yylineno; 
extern int yylex();  // Lexical analyzer function
extern char *yytext;  // Lexer text buffer
void yyerror(const char *s);  // Error handler

Node* root = nullptr;  // Global root for AST

%}

// Syntax Analysis (Parser) using Bison.
// - Uses the tokens generated by the scanner.
// - Validates the grammar based on MiniJava EBNF.
// - Constructs an Abstract Syntax Tree (AST).

%debug
%expect 1

%union {
    char* sval;       // For IDENTIFIER, STRING
    int ival;         // For NUMBER
    Node* node;       // For AST nodes
}

// Token declarations
%token CLASS PUBLIC STATIC VOID MAIN INT BOOLEAN RETURN IF ELSE WHILE PRINTLN
%token THIS NEW TRUE FALSE
%token LPAREN RPAREN LBRACE RBRACE LBRACKET RBRACKET SEMICOLON COMMA DOT ASSIGN
%token AND OR EQUAL LT GT PLUS MINUS MULT NOT

%type <node> Goal MainClass MainArgs ClassDeclarations ClassDeclaration VarDeclarations MethodDeclarations StatementList Statement Expression MethodDeclaration ParamList VarDeclaration Type
%token <sval> IDENTIFIER STRING STRING_LITERAL
%token <ival> NUMBER

// Operator precedence and associativity
%right ASSIGN           
%left OR                
%left AND               
%left EQUAL             
%left LT GT             
%left PLUS MINUS        
%left MULT              
%right NOT              
%left LPAREN RPAREN LBRACKET RBRACKET  

%start Goal

%%

// Root structure
Goal:
    MainClass ClassDeclarations
    {
        root = new Node("PROGRAM", "PROGRAM", yylineno);
        root->add_child($1);
        root->add_child($2);
    }
    ;

MainClass: 
    CLASS IDENTIFIER LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET MainArgs RPAREN LBRACE StatementList RBRACE RBRACE
    {
        $$ = new Node("MainClass", "MainClass", yylineno);
        $$->add_child(new Node("IDENTIFIER", $2, yylineno));
        if ($12) $$->add_child($12);
        if ($15) $$->add_child($15);
    };

MainArgs:
    IDENTIFIER
    {
        $$ = new Node("MainArgs", "MainArgs", yylineno);
        $$->add_child(new Node("IDENTIFIER", $1, yylineno));
    }
    | { $$ = nullptr; }
;

ClassDeclarations:
    { $$ = new Node("EMPTY_CLASS_DECL", "EMPTY_CLASS_DECL", yylineno); }
    | ClassDeclarations ClassDeclaration
    {
        $$ = $1;
        $$->add_child($2);
    }
    ;

ClassDeclaration:
    CLASS IDENTIFIER LBRACE VarDeclarations MethodDeclarations RBRACE
    {
        $$ = new Node("CLASS_DECL", $2, yylineno);
        $$->add_child($4);
        $$->add_child($5);
    }
    ;

VarDeclarations:
    { $$ = new Node("EMPTY_VAR_DECL", "EMPTY_VAR_DECL", yylineno); }
    | VarDeclarations VarDeclaration
    {
        $$ = $1;
        $$->add_child($2);
    }
    ;

VarDeclaration:
    Type IDENTIFIER SEMICOLON
    {
        $$ = new Node("VAR_DECL", $2, yylineno);
        $$->add_child($1);
    }
    ;

MethodDeclarations:
    { $$ = new Node("EMPTY_METHOD_DECL", "EMPTY_METHOD_DECL", yylineno); }
    | MethodDeclarations MethodDeclaration
    {
        $$ = $1;
        $$->add_child($2);
    }
    ;

MethodDeclaration:
    PUBLIC Type IDENTIFIER LPAREN ParamList RPAREN LBRACE VarDeclarations StatementList RETURN Expression SEMICOLON RBRACE
    {
        $$ = new Node("METHOD_DECL", $3, yylineno);
        $$->add_child($2);
        $$->add_child($5);
        $$->add_child($8);
        $$->add_child($9);
    }
    ;

ParamList:
    { $$ = new Node("EMPTY_PARAM", "EMPTY_PARAM", yylineno); }
    | Type IDENTIFIER
    {
        $$ = new Node("PARAM", $2, yylineno);
        $$->add_child($1);
    }
    ;

Type:
    INT { $$ = new Node("INT_TYPE", "int", yylineno); }
    | BOOLEAN { $$ = new Node("BOOLEAN_TYPE", "boolean", yylineno); }
    | IDENTIFIER { $$ = new Node("IDENTIFIER", $1, yylineno); }
    ;

StatementList:
    Statement StatementList
    {
        $$ = new Node("StatementList", "StatementList", yylineno);
        $$->add_child($1);
        $$->add_child($2);
    }
    | { $$ = nullptr; }
;

Statement:
    LBRACE StatementList RBRACE { $$ = $2; }
    | IF LPAREN Expression RPAREN Statement
    {
        $$ = new Node("IF", "if", yylineno);
        $$->add_child($3);
        $$->add_child($5);
    }
    | IF LPAREN Expression RPAREN Statement ELSE Statement
    {
        $$ = new Node("IF_ELSE", "if_else", yylineno);
        $$->add_child($3);
        $$->add_child($5);
        $$->add_child($7);
    }
    | WHILE LPAREN Expression RPAREN Statement
    {
        $$ = new Node("WHILE", "while", yylineno);
        $$->add_child($3);
        $$->add_child($5);
    }
    | PRINTLN LPAREN Expression RPAREN SEMICOLON
    {
        $$ = new Node("PRINTLN", "println", yylineno);
        $$->add_child($3);
    }
    | IDENTIFIER ASSIGN Expression SEMICOLON
    {
        $$ = new Node("ASSIGN", "=", yylineno);
        $$->add_child(new Node("IDENTIFIER", $1, yylineno));
        $$->add_child($3);
    }
    ;

Expression:
    Expression AND Expression { $$ = new Node("AND", "&&", yylineno); $$->add_child($1); $$->add_child($3); }
    | Expression OR Expression { $$ = new Node("OR", "||", yylineno); $$->add_child($1); $$->add_child($3); }
    | Expression LT Expression { $$ = new Node("LT", "<", yylineno); $$->add_child($1); $$->add_child($3); }
    | Expression GT Expression { $$ = new Node("GT", ">", yylineno); $$->add_child($1); $$->add_child($3); }
    | Expression EQUAL Expression { $$ = new Node("EQUAL", "==", yylineno); $$->add_child($1); $$->add_child($3); }
    | Expression PLUS Expression { $$ = new Node("PLUS", "+", yylineno); $$->add_child($1); $$->add_child($3); }
    | Expression MINUS Expression { $$ = new Node("MINUS", "-", yylineno); $$->add_child($1); $$->add_child($3); }
    | Expression MULT Expression { $$ = new Node("MULT", "*", yylineno); $$->add_child($1); $$->add_child($3); }
    | NOT Expression { $$ = new Node("NOT", "!", yylineno); $$->add_child($2); }
    | LPAREN Expression RPAREN { $$ = $2; }
    | NUMBER { $$ = new Node("NUMBER", to_string($1), yylineno); }
    | IDENTIFIER { $$ = new Node("IDENTIFIER", $1, yylineno); }
    | STRING_LITERAL { $$ = new Node("STRING_LITERAL", $1, yylineno); }
    ;

%%

void yyerror(const char *s) {
    cerr << "Parse error: " << s << " at line " << yylineno << ", token: " << yytext << endl;
}

int main() {
    yydebug = 1;  // Enable debug output

    if (yyparse() == 0) {
        cout << "Parsing completed successfully!\n";
        if (root) {
            root->print_tree();
            root->generate_tree();
        }
    } else {
        cout << "Parsing failed.\n";
    }
    return 0;
}
